use serde::Serialize;
use serde_repr::Serialize_repr;
use toml_comment::{util, TomlSchema, TomlConfig};

#[test]
fn test_basic() {
    /// this is root comment
    #[derive(Debug, TypeInfo, Serialize, Default)]
    struct Test {
        /// comment of field `a`
        a: i32,
        /// this is comment of test3
        #[serde(rename(serialize = "test3"))]
        text1: Test1,
    }

    /// comment struct Test1
    #[derive(Debug, TypeInfo, Serialize, Default)]
    struct Test1 {
        /// comment of field `b`
        b: i32,
    }
    let test = Test::default();
    let config = TomlConfig(test);
    let left = r"# this is root comment

# comment of field `a`
a = 0

# this is comment of test3
# comment struct Test1
[test3]
# comment of field `b`
b = 0";
    assert_eq!(left, config.to_string());
    // println!("{}", config.to_string());
}

#[test]
fn test_flatten() {
    /// this is root comment
    #[derive(Debug, TypeInfo, Serialize, Default)]
    struct Test {
        /// comment of field `a`
        a: i32,
        /// this is comment of test1
        #[serde(flatten)]
        text1: Test1,
    }

    #[derive(Debug, TypeInfo, Serialize, Default)]
    struct Test1 {
        /// comment of field `b`
        b: i32,
    }
    let test = Test::default();
    let config = TomlConfig(test);
    let left = r"# this is root comment

# comment of field `a`
a = 0
# comment of field `b`
b = 0";
    assert_eq!(left, config.to_string());
}

#[test]
fn test_option() {
    /// this is root comment
    #[derive(Debug, TypeInfo, Serialize)]
    struct Test {
        /// comment Option i32
        a: Option<i32>,
        /// comment Option string
        b: Option<String>,
        /// comment Option Test1
        c: Option<Test1>,
    }

    impl  Default for Test {
        fn default() -> Self {
            Test { a: None, b: Some("test".to_string()), c: None }
        }
    }

    #[derive(Debug, TypeInfo, Serialize)]
    struct Test1 {
        /// comment  i32
        a1: Option<i32>,
        /// comment Option string
        b1: Option<String>,
    }

    impl Default for Test1 {
        fn default() -> Self {
            Test1 { a1: None, b1: Some("test b1".to_string()) }
        }
    }

    let test = Test::default();
    let config = TomlConfig(test);
    println!("{}", config.to_string());
}

#[test]
fn test_enum() {
    /// this is root comment
    #[derive(Debug, TomlSchema, Serialize_repr)]
    #[repr(u8)]
    enum TestEnum {
        /// comment A
        A = 0,
        /// comment B
        B = 1,
    }

    impl  Default for TestEnum {
        fn default() -> Self {
            TestEnum::B
        }
    }

    println!("{:?}", TestEnum::type_info());

    let test = TestEnum::default();
    // println!("{}", value_to_string(&test).unwrap());

    #[derive(Debug, TomlSchema, Serialize, Default)]
    /// comment Test
    struct Test {
        /// comment `a``
        a: TestEnum
    }
    // println!("{:?}", Test::type_info());
    let test = Test::default();
    let config = TomlConfig(test);
    println!("{}", config.to_string());

}